# 7. 함수(Function)와 전처리 지시문(Preprocessor Directives)

함수(Function)는 하나의 작업 단위를 정의한 코드 블록이다.  
우리가 지금까지 사용한 `printf()`, `scanf()`도 사실은 C언어 라이브러리 안에 이미 만들어져 있는 함수였다.  
이번에는 우리가 직접 새로운 함수를 만들어서 사용하는 방법을 배운다.

함수를 사용하면 다음과 같은 장점이 있다:

- 같은 코드를 여러 번 복사하지 않고도 재사용 가능
- 프로그램의 흐름이 더 잘 보이고 구조가 명확해짐
- 코드의 가독성과 유지보수성이 좋아짐

## 함수의 기본 구조

```c
반환형 함수이름(매개변수 목록)
{
    // 수행할 작업
    return 결과값;
}
```

| 요소      | 설명                                       |
| --------- | ------------------------------------------ |
| 반환형    | 함수가 계산하고 되돌려주는 결과값의 자료형 |
| 함수 이름 | 호출할 때 사용할 함수의 이름               |
| 매개변수  | 함수에 전달할 입력값(변수)                 |
| 함수 몸체 | 실제 동작을 수행하는 코드 블록             |

## 예시: 두 수를 더하는 함수

```c
int add(int a, int b)
{
    return a + b;
}
```

### 함수 호출:

```c
int result = add(3, 5);  // result에 8이 저장됨
```

> `add(3, 5)`라고 함수를 호출하면 `a`에는 3, `b`에는 5가 복사되어 전달된다.  
> 함수 내부에서 `a`, `b`를 바꿔도 원래 값은 바뀌지 않는다.  

## 함수 매개변수는 복사(copy)된다

C언어에서 함수의 매개변수는 값이 복사되어 전달된다.  
즉, 함수 내부에서 매개변수를 수정해도 원래 변수에는 아무 영향이 없다.

### 예시:

```c
void set_zero(int value)
{
    value = 0;
}

int main(void)
{
    int num = 10;
    set_zero(num);
    printf("%d\n", num);  // 출력: 10
    return 0;
}
```

- `set_zero(num)` 호출 시 `value = 10`이지만, `value`는 num의 복사본
- 함수 안에서 `value = 0`으로 바꿔도 `main()`의 `num`은 변하지 않는다

> 즉, 매개변수는 원본이 아닌 복사본을 받는다.

## `void` 함수와 반환값이 있는 함수

- `int`, `float` 등: 결과값을 계산해서 `return`으로 돌려주는 함수
- `void`: 아무 값도 돌려주지 않고 동작만 수행하는 함수

```c
void say_hello(void)
{
    printf("Hello, World!\n");
}
```

### 사용 예:

```c
say_hello();  // 출력: Hello, World!
```

## 함수 선언과 정의

함수를 직접 구현하고 사용하려면 먼저 관련 용어들의 의미를 정확히 이해해야 한다.

| 용어                             | 설명                                                                       |
| -------------------------------- | -------------------------------------------------------------------------- |
| 함수 원형 (Function Prototype)   | 반환형 + 함수 이름 + 매개변수 목록으로 구성된 함수의 구조적인 형태         |
| 함수 선언 (Function Declaration) | 함수 원형을 코드 상에 작성하여 컴파일러에게 해당 함수의 존재를 알리는 문장 |
| 함수 정의 (Function Definition)  | 함수 원형에 구현부(body) 까지 포함하여 실제로 동작하도록 만든 것           |

## 📌 예시

```c
// 함수 선언 (함수 원형을 선언문으로 작성)
int add(int a, int b);

int main(void)
{
    int sum = add(2, 3);
    printf("%d", sum);
    return 0;
}

// 함수 정의 (원형 + 구현부)
int add(int a, int b)
{
    return a + b;
}
```

> 함수 선언은 보통 헤더 파일(.h) 에 작성하고 함수 정의는 소스 파일(.c) 에 작성하는 것이 일반적인 방식이다.

```c
// example.h
#ifndef EXAMPLE_H
#define EXAMPLE_H

int add(int a, int b);

#endif /* EXAMPLE_H */

// example.c
#include "example.h"

int add(int a, int b)
{
    return a + b;
}

/// main.c
#include <stdio.h>
#include "example.h"

int main(void)
{
    int sum = add(2, 3);
    printf("%d\n", sum);
    return 0;
}
```

# 전처리 지시문 (Preprocessor Directives)

전처리 지시문은 C언어 프로그램을 컴파일하기 전에 미리 처리되는 명령이다.  
항상 `#`으로 시작하며, 소스코드를 확장하거나 정리하는 데 사용된다.

## `#include`: 헤더 파일 포함

```c
#include <stdio.h>
```

- `#include`는 지정된 파일의 내용을 현재 파일에 삽입하라는 지시다.
- 주로 함수 선언, 매크로 정의, 구조체 정의 등을 다른 파일에서 가져올 때 사용한다.

### 두 가지 형태

| 형태                   | 설명                                                                     |
| ---------------------- | ------------------------------------------------------------------------ |
| `#include <파일명>`    | 시스템 헤더 파일을 포함한다. 일반적으로 표준 라이브러리 파일에 사용된다. |
| `#include "파일명"`    | 사용자 정의 헤더 파일을 포함한다. 현재 디렉터리부터 검색한다.            |

## `#define`: 매크로 정의

```c
#define PI (3.14159)
#define MAX_COUNT (100)
```

- `#define`은 매크로(Macro)를 정의한다.
- 해당 이름을 사용한 모든 부분을, 컴파일 전 단계에서 지정된 값으로 치환한다.
- 자료형 없이 문자열 수준의 단순 치환만 수행된다.

> 주의: 우선순위 오류 방지를 위해 반드시 괄호로 감싸는 습관을 들여야 한다.  
> 예: #define SQUARE(x) ((x) * (x))

## 조건부 컴파일: `#ifndef`, `#define`, `#endif`

C 언어에서는 같은 헤더 파일이 여러 번 포함되면 중복 선언 오류가 발생할 수 있다.  
이를 방지하기 위해 조건부 컴파일 지시문을 사용하여 한 번만 포함되도록 제어한다.

### 예시:

```c
#ifndef MY_HEADER_H
#define MY_HEADER_H

// 이 안의 내용은 한 번만 포함됨

#endif /* MY_HEADER_H */
```

| 지시문    | 의미                                                                       |
| --------- | -------------------------------------------------------------------------- |
| `#ifndef` | 매크로가 정의되지 않았을 때만 아래 코드를 처리한다.                        |
| `#define` | 매크로를 정의한다.                                                         |
| `#endif`  | 조건부 컴파일 영역의 종료를 나타낸다.(주석까지 적어주는것이 일반적인 관습) |

### 작동 원리

1. 처음 포함될 때 `MY_HEADER_H`가 정의되어 있지 않으므로 내용이 포함된다.
2. 이후 다른 파일에서 다시 동일한 파일을 #include 해도 이미 `MY_HEADER_H`가 정의된 상태이므로 내용은 무시된다.

## 전처리 지시문 정리

| 지시문 | 기능 | 예시 |
| -------------------------------- | ------------------------------------- | -------------------------------------------------------------------------- |
| `#include`                       | 지정한 파일의 내용을 현재 파일에 삽입 | `#include <stdio.h>`                                                       |
| `#define`                        | 매크로 이름과 값을 정의               | `#define PI (3.14)`                                                        |
| `#ifndef` / `#define` / `#endif` | 조건부 컴파일 (헤더 중복 방지)        | `#ifndef MY_HEADER_H` / `#define MY_HEADER_H` / `#endif /* MY_HEADER_H */` |

## 자주 하는 실수들

- 함수에 `return`을 빼먹거나 잘못된 값을 반환함
- `#include`를 빠뜨려 함수 선언이 누락되어 컴파일 오류 발생
- `#define`으로 수식을 정의할 때 괄호를 생략하여 연산 우선순위 오류 발생
- 조건부 컴파일을 빠뜨려 헤더 중복 선언으로 컴파일 에러 발생

## 정리

* 함수는 코드의 재사용성과 구조화를 돕는다.
* 매개변수는 값이 복사되어 전달되며, 원본은 바뀌지 않는다.
* `void`는 반환값 없는 함수에 사용된다.
* `#include`는 다른 파일의 내용을 삽입하며 `#define`은 치환용 매크로를 정의한다.
* 조건부 컴파일(`#ifndef`, `#define`, `#endif`)은 헤더 중복 포함을 방지하는 데 필수적이다.