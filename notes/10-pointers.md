# 10. 포인터 (Pointers)

## 왜 포인터를 사용할까

함수에 어떤 값을 넘겨주었는데 함수 안에서 그 값을 바꿨음에도 함수 밖에서는 값이 그대로인 것처럼 보였던 적이 있을 수 있다.

```c
void set_zero(int x)
{
    x = 0;
}
```

```c
int main(void)
{
    int a = 10;
    set_zero(a);
    printf("%d\n", a);  // 출력: 10 (값이 바뀌지 않음)
}
```

이유는 C에서 함수에 인자를 전달하면 복사본이 넘어가기 때문이다. 즉, 함수 내부에서 값을 바꾸어도 원래 변수는 바뀌지 않는다.

그렇다면 함수가 변수의 원본 값을 바꾸려면 어떻게 해야 할까? 이럴 때 사용하는 것이 포인터이다.

포인터는 변수의 주소, 즉 위치를 저장하는 변수이다. 이 주소를 사용하면 원래 값을 직접 바꾸는 것이 가능해진다.

## 포인터란

포인터는 어떤 변수의 주소를 저장하는 변수이다.

```c
int a = 10;
int* p = &a;
```

- `&a`는 변수 `a`의 주소를 구한다.
- `int* p`는 정수를 가리키는 포인터를 선언한다.
- `*p`는 포인터 `p`가 가리키는 주소에 저장된 값이다.

여기서 `*`는 두 가지 의미로 사용된다.

| 형태 | 설명 |
|------|------|
| `int* p` | 포인터 변수를 선언하는 문법 |
| `*p` | 포인터가 가리키는 주소에 저장된 값에 접근 (역참조) |

## 포인터 선언 방법

```c
int* p;     // 정수를 가리키는 포인터
char* cp;   // 문자를 가리키는 포인터
float* fp;  // 실수를 가리키는 포인터
```

`int *p`, `int* p`, `int * p` 모두 문법적으로는 동일하다. 하지만 `int* p`처럼 자료형과 붙여 쓰는 것이 포인터 변수라는 점을 명확히 보여주기 때문에 일반적으로 추천된다.

주의할 점은 다음과 같다.

```c
int* a, b;
```

이 경우 `a`는 포인터지만 `b`는 일반 `int` 변수이다. 이런 혼동을 줄이기 위해서 `*`는 자료형과 붙이는 것이 좋다.  
그리고 변수는 한 줄에 하나씩만 선언하는 습관을 들이는 것이 좋다.

## 포인터 사용 예시

```c
#include <stdio.h>

int main(void)
{
    int a = 5;
    int* p = &a;

    printf("a의 값: %d\n", a);          // 변수 a의 값 출력
    printf("a의 주소: %p\n", &a);       // 변수 a의 주소 출력
    printf("p의 값(주소): %p\n", p);    // p에 저장된 주소 출력
    printf("p가 가리키는 값: %d\n", *p); // p가 가리키는 값 출력

    *p = 10;  // p가 가리키는 곳의 값을 10으로 변경
    printf("바뀐 a의 값: %d\n", a);     // 실제 변수 a도 바뀜

    return 0;
}
```

포인터를 사용하면 값에 간접적으로 접근하거나 수정할 수 있다.

## 두 변수의 값을 바꾸는 예시

```c
void swap(int* x, int* y)
{
    int temp = *x;  // x가 가리키는 값을 임시 변수에 저장
    *x = *y;        // y가 가리키는 값을 x가 가리키는 곳에 저장
    *y = temp;      // 임시 변수 값을 y가 가리키는 곳에 저장
}
```

```c
int main(void)
{
    int a = 3;
    int b = 7;
    swap(&a, &b);
    printf("a: %d, b: %d\n", a, b);  // a: 7, b: 3
    return 0;
}
```

포인터를 사용하면 함수가 원본 값을 바꿀 수 있다.

## 배열과 포인터

배열 이름은 배열의 첫 번째 요소의 주소를 의미한다. 즉, 배열 이름은 포인터처럼 사용할 수 있다.

```c
int nums[5] = {10, 20, 30, 40, 50};
int* p = nums;     // nums == &nums[0]
```

`nums[2]`는 `*(nums + 2)`와 같다.

## 배열을 함수에 전달하는 경우

```c
void fill_zero(int arr[], int size)
{
    for (int i = 0; i < size; ++i) {
        arr[i] = 0;
    }
}
```

```c
int main(void)
{
    int data[3] = {1, 2, 3};
    fill_zero(data, 3);

    for (int i = 0; i < 3; ++i) {
        printf("%d\n", data[i]);  // 출력: 0 0 0
    }
    return 0;
}
```

배열을 함수에 전달하면 배열 전체가 복사되는 것이 아니라 주소만 전달된다.  
그래서 함수 안에서 배열의 값을 바꾸면 원본 배열도 바뀐다.

## NULL 포인터

포인터가 어떤 것도 가리키지 않게 하려면 `NULL`을 사용한다.

```c
int* p = NULL;
```

`NULL`은 보통 `(void*)0`으로 정의된 매크로 상수이다.

`NULL`을 사용할 때는 역참조하기 전에 반드시 `NULL`인지 확인해야 한다.  
그렇지 않으면 프로그램이 비정상적으로 종료될 수 있다.

```c
if (p != NULL)
{
    printf("%d\n", *p);
}
```

## 정리

* 포인터는 변수의 주소를 저장하는 변수이며 `*`와 `&`로 선언/접근한다.
* 포인터를 사용하면 함수에서 원본 값을 수정할 수 있다.
* 배열 이름은 포인터와 거의 동일하게 동작한다 (`nums == &nums[0]`).
* NULL 포인터는 반드시 확인하고 역참조해야 한다.
* 포인터 선언은 `int* p`처럼 타입과 붙여 쓰는 것이 권장된다.


> 프로그래밍을 처음 배우는 입장에서 지금처럼 포인터의 사용법 정도를 익히고 넘어가도 충분하다.  
> 하지만 전공자의 입장에서 컴퓨터 메모리를 충분히 이해하고 난 뒤 포인터를 꼼꼼하게 이해할 필요가 있다.