# 12. 구조체와 typedef

지금까지 우리는 `int`, `float`, `char` 같은 하나의 값만 저장할 수 있는 자료형만 사용해왔다. 그런데 실제 문제에서는 이름, 나이, 학번처럼 여러 개의 서로 다른 값을 하나의 덩어리로 묶어서 다루고 싶은 경우가 자주 생긴다.

예를 들어, 학생 1명을 표현하려면 다음과 같이 각각의 변수로 선언해야 한다:

```c
char name[20];
int age;
float gpa;
```

학생이 한 명일 때는 이 방식으로도 문제가 없다. 하지만 학생이 여러 명이라면 상황은 달라진다. 예를 들어 학생이 100명이라면?

```c
char names[100][20];
int ages[100];
float gpas[100];
```

이렇게 선언하면 구조는 갖추었지만, 이름 `names[5]`, 나이 `ages[5]`, 평점 `gpas[5]`가 모두 같은 학생을 의미한다는 것을 명확하게 표현하지 못한다.
또한 실수로 서로 다른 인덱스를 사용하는 경우에도 컴파일러는 이를 전혀 경고해주지 않는다.

즉, 현실 세계의 '학생'이라는 개념은 이름, 나이, 성적이 함께 묶여야 하나의 개체로 의미가 있는데, 배열 방식은 이를 구조적으로 표현하지 못한다.

이럴 때 필요한 것이 바로 구조체(struct) 이다.

## 구조체란?

구조체는 서로 다른 자료형의 값을 하나로 묶어서 새로운 자료형을 만드는 기능이다.
즉, 현실 세계의 개체(학생, 책, 자동차 등)를 프로그래밍 언어 수준에서 하나의 단위로 표현할 수 있게 해주는 도구이다.

```c
struct student {
    char name[20];
    int age;
    float gpa;
};
```

이제 `struct student`는 이름, 나이, 평점을 한 번에 다룰 수 있는 새로운 타입이 된다. 즉, '학생'이라는 개념 자체를 하나의 사용자 정의 자료형으로 만들 수 있게 된 것이다.

> 구조체도 `int`, `float`처럼 사용자가 새롭게 정의한 자료형일 뿐이다. 이 자료형도 변수 선언, 대입, 함수 전달 등 모든 면에서 기존 타입과 동일하게 사용할 수 있다.

### 구조체 변수 선언

```c
struct student alice;
```

### 멤버 접근

```c
strcpy(alice.name, "Alice");
alice.age = 20;
alice.gpa = 4.3f;
```

> 구조체 멤버에 접근할 때는 `.` 연산자를 사용한다.

### 구조체를 함수에 전달

```c
void print_student(struct student s)
{
    printf("이름: %s, 나이: %d, 평점: %.2f\n", s.name, s.age, s.gpa);
}
```

> 구조체는 값이 복사되어 전달되므로 크기가 큰 구조체를 넘길 경우 메모리 낭비가 발생할 수 있다.

이 문제를 해결하기 위해 구조체를 포인터로 전달할 수도 있다:

```c
void print_student_ptr(const struct student* ps)
{
    printf("이름: %s, 나이: %d, 평점: %.2f\n", ps->name, ps->age, ps->gpa);
}
```

> 구조체 포인터는 `*`로 역참조한 뒤 `.` 연산자를 적용하는 것이 번거롭기 때문에, C에서는 이를 간단히 쓸 수 있도록 `->` 연산자를 제공한다.
> 즉, `ps->age`는 `(*ps).age`와 완전히 같은 의미이다.

### 구조체 배열

```c
struct student class_members[3];
```

구조체도 배열처럼 여러 개를 선언해서 사용할 수 있다. 이 경우 각 배열 요소는 이름, 나이, 평점을 모두 포함한 하나의 '학생' 개체가 된다.

### 구조체를 리턴하는 함수

구조체는 함수의 반환값으로도 사용할 수 있다. 예를 들어 아래처럼 `student` 구조체를 만들어서 리턴할 수 있다:

```c
struct student create_student(const char* name, int age, float gpa)
{
    struct student s;
    strcpy(s.name, name);
    s.age = age;
    s.gpa = gpa;
    return s;
}
```

이처럼 구조체도 다른 타입과 동일하게 변수로 선언하고, 함수 인자로 전달하고, 함수에서 리턴할 수 있는 '자료형'이라는 점을 명확히 이해하자.

## 구조체를 사용하다 보면 생기는 불편함: 이름이 너무 길다

매번 `struct student`라고 쓰는 것은 귀찮고 코드도 지저분하다. 예를 들어:

```c
struct student bob, charlie;
struct student class_members[30];
```

이런 식으로 매번 `struct`를 붙이다 보면 코드가 길어지고, 타입 이름으로서의 명확성도 떨어질 수 있다.

그래서 C에서는 typedef라는 기능을 제공해서 구조체에 별명을 붙일 수 있다.

## typedef로 구조체에 별칭 붙이기

```c
typedef struct student {
    char name[20];
    int age;
    float gpa;
} student_t;
```

이제부터는 `struct student` 대신 `student_t`를 자료형처럼 사용할 수 있다:

```c
student_t diana;
```

이처럼 `typedef`를 사용하면 코드가 더 짧고 명확해지며, 다른 개발자와 협업할 때도 가독성이 좋아진다.

### 왜 `_t`를 붙일까?

C 표준 라이브러리에서는 `size_t`, `time_t`, `FILE` 등 다양한 사용자 정의 타입에 `_t` 접미사를 붙인다.
이것은 이 이름이 '타입(type)'이라는 것을 명확하게 표현하기 위해서이다.

또한 다음과 같은 이유로 `_t` 접미사를 사용하는 것이 좋다:

* 변수나 상수와 이름이 겹치지 않음
* 사용자 정의 타입이라는 것을 한눈에 파악할 수 있음
* 일관된 네이밍 규칙은 코드 가독성과 유지보수성을 높여줌

## 자주 하는 실수들

* 구조체 정의 끝에 세미콜론(`;`)을 빼먹음
* `.` 연산자와 `->` 연산자를 헷갈림 (`->`는 `(*포인터).멤버`의 축약형)

## 정리

* 구조체는 서로 다른 자료형을 묶어 새로운 사용자 정의 자료형을 만든다.
* 멤버 접근은 `.` 또는 포인터일 경우 `->`를 사용한다.
* `typedef`로 별칭을 붙이면 코드가 더 짧고 명확해진다.
* 구조체도 함수 인자, 반환값, 배열 요소로 자유롭게 사용할 수 있다.
* 별칭에는 `_t` 접미사를 붙이는 것이 일반적이다.
