# 15. 컴퓨터에서의 수 체계 (Number Systems in Computers)

컴퓨터는 내부적으로 `0`과 `1` 두 가지 상태만을 인식한다. 이 두 상태는 각각 하나의 비트(bit)를 의미하며 컴퓨터는 이 비트들의 조합을 통해 모든 데이터를 저장하고 처리한다.  
즉 우리가 다루는 숫자, 문자, 이미지, 영상, 소리, 명령어 등은 모두 `0`과 `1`로 이루어진 이진수(binary digits)로 변환되어야 컴퓨터가 이해하고 조작할 수 있다.

이러한 이진수는 어떻게 해석하느냐에 따라 정수, 실수, 문자, 색상 정보 등 다양한 의미를 가질 수 있으며 컴퓨터는 정해진 해석 규칙(자료형, 인코딩 방식 등)에 따라 이 데이터를 의미 있는 정보로 처리한다.

> 예를 들어 `01000001₍₂₎`이라는 8비트 이진수는 정수로 보면 65이고, 문자로 해석하면 'A'(ASCII 기준)이다.

이 문서에서는 이진수가 표현할 수 있는 다양한 데이터 중에서도 정수(integer)를 중심으로 다룬다.

컴퓨터가 정수를 어떻게 이진수로 저장하고 해석하는지에 대한 원리를 이해함으로써 컴퓨터 내부의 데이터 표현 방식에 대한 기초 개념을 확립하는 것이 목적이다.

여기서 배우는 진법, 데이터 단위, 정수 표현 방식 등의 개념은 이후 다른 과목에서 접하게 될 실수, 문자, 색상, 명령어 등 다양한 데이터가 컴퓨터에서 어떻게 저장되고 변환되는지를 이해하는 데 필요한 기반 지식이 된다.

## 진법(Number Bases)과 변환

### N진법이란?

진법이란 한 자리에 사용할 수 있는 숫자의 종류가 N개인 수 체계를 의미한다.

| 진법   | 사용 가능한 숫자 | 예시                           |
| ------ | ---------------- | ------------------------------ |
| 2진수  | 0, 1             | `1011₍₂₎` 또는 `0b1011` = `11` |
| 8진수  | 0 ~ 7            | `75₍₈₎` 또는 `075` = `61`      |
| 10진수 | 0 ~ 9            | `42₍₁₀₎` 또는 `42`             |
| 16진수 | 0 ~ 9, A ~ F     | `1F₍₁₆₎` 또는 `0x1F` = `31`    |

N진수 표기 방법: 숫자의 진법을 명확히 구분하기 위해 하첨자 또는 접두어를 사용한다. 컴퓨터공학에서는 하첨자보다 접두어로 표기를 더 널리 사용한다.
- 2진수 접두어: `0b`
- 8진수 접두어: `0`
- 16진수 접두어: `0x`

표기가 없는 경우 일반적으로 10진수로 해석한다.

### 다양한 진법간의 변환과 관계

#### 2진수 <-> 10진수 변환

* 2진수 -> 10진수 변환
    1. 2진수의 맨 오른쪽부터 각 자릿수와 자릿수에 해당하는 값을 곱한다.
    2. 모든 곱의 결과를 더한다.
   
    `0b1011` → `1×2³ + 0×2² + 1×2¹ + 1×2⁰ = 8 + 0 + 2 + 1` = `11`

* 10진수 -> 2진수 변환
    1. 10진수를 2로 나누고 나머지를 기록한다.
    2. 나눈 몫을 또 다시 2로 나누고 나머지를 기록한다.
    3. 이렇게 계속해서 2로 나누고 몫이 0이 되면 중단한다.
    4. 지금까지 기록한 나머지들을 역으로 연결한다.

    `11` →  
    `11 ÷ 2 = 5 ... 1`  
    `5 ÷ 2 = 2 ... 1`  
    `2 ÷ 2 = 1 ... 0`  
    `1 ÷ 2 = 0 ... 1`   
    = `0b1011`

#### 2진수 <-> 8진수 변환

* 2진수 -> 8진수 변환
    1. 2진수를 세 자리씩 끊어 8진수 한자리로 변환한다.
    2. 세 자리로 끊을 수 없다면 앞에 0을 추가하여 세 자리씩 끊는다.

    `0b11011010` → `011 011 010` → `3 3 2` = `0332`

* 8진수 -> 2진수 변환

    * 8진수의 각 자리를 세 자리의 2진수로 변환한다.

    `075` → `111 101` = `0b111101`

이렇게 쉽게 상호 변환이 가능한 이유는 8 = 2³이기 때문이다.  
즉 8진수의 각 한 자리는 2진수의 세 자리와 동일하다.

#### 2진수 <-> 16진수 변환

* 2진수 -> 16진수 변환
    1. 2진수를 네 자리씩 끊어 16진수 한 자리로 변환한다.
    2. 네 자리로 끊을 수 없다면 앞에 0을 추가하여 네 자리씩 끊는다.
   
    `0b11011010` → `1101 1010` → `D A` = `0xDA`

* 16진수 -> 2진수 변환

    * 16진수의 각 자리를 네 자리의 2진수로 변환한다.

    `0x1F` → `0001 1111` = `0b00011111`

이렇게 쉽게 상호 변환이 가능한 이유는 16 = 2⁴이기 때문이다.  
즉, 16진수의 각 한자리는 2진수의 네자리와 동일하다.

> 이 외의 진수끼리 곧바로 상호 변환하기는 쉽지 않다. 따라서 중간에 2진수로 변환한 후 변환하고자 하는 진수로 변환하는 것이 유리하다.
> 
> `075` → `0b111101` → `0011 1101` → `3 D` = `0x3D`

## 비트와 바이트

* 비트(bit): 컴퓨터가 표현할 수 있는 가장 작은 단위로 `0` 또는 `1`의 값을 가진다
* 바이트(byte): 8개의 비트로 구성되며 대부분의 컴퓨터 시스템은 1바이트를 기본 처리 단위로 사용한다.

### 컴퓨터의 기본 데이터 단위

| 단위            | 크기 (비트 기준)       |
| --------------- | ---------------------- |
| 1 Byte (B)      | 8 bits                 |
| 1 Kilobyte (KB) | 1024 Bytes = 2¹⁰ Bytes |
| 1 Megabyte (MB) | 1024 KB = 2²⁰ Bytes    |
| 1 Gigabyte (GB) | 1024 MB = 2³⁰ Bytes    |
| 1 Terabyte (TB) | 1024 GB = 2⁴⁰ Bytes    |

> 실제 저장장치나 네트워크에서는 1KB = 1000B로 표기하는 경우도 종종 있다.

## 컴퓨터에서의 정수 표현

부호 없는 정수(Unsigned Integer)는 부호를 고려하지 않고 0 이상의 양의 정수만을 표현하는 방식이다.  

이 경우 각 비트는 수의 크기를 나타내는 용도로만 사용되며 비트 패턴을 그대로 2진수로 해석하면 된다. 예를 들어 8비트로 표현할 경우 `0b00000000`은 0, `0b11111111`은 255로 해석된다. 

n비트로 표현 가능한 부호 없는 정수의 범위는 항상 0부터 2ⁿ - 1까지이다.

반면 우리가 사용하는 정수는 양수와 음수를 모두 포함하지만 기본적인 2진수 표기 방식은 자연수만을 표현할 수 있다. 이진수는 `0`과 `1`이라는 두 숫자만을 사용하여 값을 나타내며 우리가 흔히 사용하는 -5와 같은 부호 있는 수는 표현하거나 해석할 수 있는 방법이 정해져 있지 않다.

예를 들어 10진수에서는 음수를 앞에 `-`기호를 붙여 명확하게 나타낼 수 있지만 이진수에서는 이러한 부호 기호가 없기 때문에 컴퓨터가 음수를 올바르게 저장하고 처리하기 위해서는 고정된 비트 수 내에서 별도의 해석 규칙이 필요하다.

### 부호 절대값 표현(Signed Magnitude Representation)

가장 왼쪽의 비트(최상위 비트)는 부호 비트(Sign bit)로 사용하고 나머지 비트들을 절대값 비트(Magnitude bits)로 해석하는 방식이다.

- 부호 비트가 `0`이면 양수
- 부호 비트가 `1`이면 음수

절대값 비트는 부호와 무관하게 그대로 2진수를 10진수로 변환하여 정수 값을 계산한다.

`0b00000101` → 부호 비트:`+` 절대값 비트: 5 = 5  
 `0b10000101` → 부호 비트: `-` 절대값 비트: 5 = -5

즉 정수 ±5는 부호 비트만 다르고 절대값 비트는 동일하다.

양수와 음수를 모두 표현할 수 있는 훌륭한 아이디어지만 다음과 같은 한계가 있다:

1. +0과 -0이 실제로는 같은 값이지만 서로 다른 이진수로 표현된다.
    * `0b00000000` = +0
    * `0b10000000` = -0

    이처럼 0이 두 가지 이진수(+0, -0)로 중복 표현되면 연산 처리와 비교 연산 시 불필요한 자원과 조건 처리가 필요해진다.

2. 양수와 음수를 더할 때 단순히 두 이진수의 비트 패턴을 더하는 것만으로는 올바른 결과를 얻을 수 없다.

    양수와 음수를 더하는 대신, 양수끼리의 뺄셈으로 바꾸어 연산하면 될 것처럼 보일 수 있다.  
    하지만 대부분의 컴퓨터는 뺄셈 연산조차도 내부적으로 덧셈을 기반으로 처리하도록 설계되어 있다.

### 1의 보수(one`s complement)

양수는 일반적인 이진수와 동일하게 표현하고 음수는 해당 양수의 모든 비트를 반전하여 표현하는 방식이다.

가장 왼쪽의 비트(최상위 비트)는 부호 비트(Sign bit)로 사용하고 나머지 비트들을 수의 크기를 나타낸다.
- 부호 비트가 `0`이면 양수
- 부호 비트가 `1`이면 음수

표현 방식
- 양수: 일반적인 이진수와 동일하게 표현한다.
- 음수: 대응하는 양수의 비트를 모두 반전시켜서 표현한다.(`0`은 `1`로, `1`은, `0`으로 바꿈).

`0b00000101` → 부호 비트: `0` (양수), 나머지 비트: `0b0000101` → 5 = +5   
`0b11111010` → 부호 비트: `1` (음수), 나머지 비트 반전: `0b0000101` → 5 = -5

덧셈 연산만으로 양수와 음수의 연산이 모두 가능한 훌륭한 아이디어지만 다음과 같은 한계가 있다:

1. +0과 -0이 실제로는 같은 값이지만 서로 다른 이진수로 표현된다.
    * `0b00000000` = +0
    * `0b11111111` → 부호 비트: `1` (음수), 나머지 비트 반전: `0b0000000` → `0` = -0

    이처럼 0이 두 가지 이진수(+0, -`0`)로 중복 표현되면 연산 처리와 비교 연산 시 불필요한 자원과 조건 처리가 필요해진다.

2. 최상위 비트에서 받아올림(carry)이 발생한다면 결과값에 `1`을 더해줘야 한다.

### 2의 보수(two`s complement)

양수는 일반적인 이진수와 동일하게 표현하고, 음수는 해당 양수의 모든 비트를 반전시킨 뒤 1을 더하여 표현하는 방식이다.


가장 왼쪽의 비트(최상위 비트)는 부호 비트(Sign bit)로 사용되고 나머지 비트들을 수의 크기를 나타낸다.
- 부호 비트가 `0`이면 양수
- 부호 비트가 `1`이면 음수

표현 방식
- 양수: 일반적인 이진수와 동일하게 표현된다.
- 음수: 대응하는 양수의 비트를 모두 반전시킨 후 `1`을 더해서 표현된다.

`0b00000101` → 부호 비트: `0` (양수), 나머지 비트: `0b0000101` → 5 = +5   
`0b11111011` → 부호 비트: `1` (음수), 나머지 비트 반전: `0b0000100` → +1: `0b0000101` → 5 = -5

2의 보수는 다음과 같은 이유로 컴퓨터에서 가장 널리 사용되는 정수 표현 방식이다:

1. 0이 단 하나의 이진수로 표현된다.
2. 덧셈 연산만으로 양수와 음수의 연산이 모두 가능하며 결과값에 별도의 보정 없이 정확한 값을 얻을 수 있다.

#### 2의 보수 방식에서 부호 전환 방법 (양수 ↔ 음수)

2의 보수 방식에서는 양수 ↔ 음수 변환할 때 동일하게 모든 비트를 반전시키고 1을 더한다.

처음에는 직관적이지 않을 수 있으나 실제로는 다음과 같이 동작한다:

* +5 → -5 변환
    * +5 → `0b00000101`
    * 비트 반전 → `0b11111010`
    * +1 → `0b11111011` → 이것이 -5의 2의 보수 표현

* -5 → +5 변환
    * -5 → `0b11111011`
    * 비트 반전 → `0b00000100`
    * +1 → `0b00000101` → 다시 +5

#### 2의 보수에서 표현 가능 범위

2의 보수에서 n비트로 표현 가능한 정수의 범위는 다음과 같다:

| 비트 수          | 표현 가능한 범위                                | 표현 가능한 수의 개수 |
| ---------------- | ----------------------------------------------- | --------------------- |
| 4비트            | -2³  ~ 2³ - 1 (-8 ~ 7)                          | 2⁴개                  |
| 8비트 (1바이트)  | -2⁷  ~ 2⁷ - 1 (-128 ~ 127)                      | 2⁸개                  |
| 16비트 (2바이트) | -2¹⁵ ~ 2¹⁵ - 1 (-32,768 ~ 32,767)               | 2¹⁶개                 |
| 32비트 (4바이트) | -2³¹ ~ 2³¹ - 1 (-2,147,483,648 ~ 2,147,483,647) | 2³²개                 |

이러한 범위는 아래 수식으로 계산할 수 있다:

- 최소값 = -2ⁿ⁻¹  
- 최대값 = 2ⁿ⁻¹ - 1  
- 총 표현 개수 = 2ⁿ

### 오버플로우(Overflow) / 언더플로우(Underflow)

컴퓨터는 정수를 일정한 개수의 비트로 표현한다. 예를 들어 4비트만 사용하는 상황에서는 오직 4개의 비트로만 모든 수를 표현하고 연산해야 한다. 이처럼 고정된 비트 수로 값을 표현하면 연산 결과가 표현 가능한 범위를 벗어날 경우 오버플로우 또는 언더플로우가 발생한다.

#### 오버플로우 (Overflow)

오버플로우는 가장 큰 수에서 더 큰 수로 증가하려고 할 때 발생한다. 고정된 비트 수를 초과하는 값은 표현할 수 없기 때문에 초과된 부분이 잘리고 결과가 반대 방향의 값으로 바뀌는 현상이다.

표현할 수 있는 최대값에서 1을 더하면 최소값으로 돌아간다고 이해해도 좋다.

* 4비트 정수 기준: `0b0111` + `0b0001` = `0b1000` 

    * 4비트 정수에서 `0b1000`은 최댓값인 7이다.
    * 여기에 1을 더하면 이론적으로 8이 되어야 하지만 `0b1000`은 -8이다.

#### 언더플로우 (Underflow)

언더플로우는 가장 작은 수에서 더 작은 수로 감소하려고 할 때 발생한다. 고정된 비트 수를 초과하는 값은 표현할 수 없기 때문에 초과된 부분이 잘리고 결과가 반대 방향의 값으로 바뀌는 현상이다.

표현할 수 있는 최소값에서 1을 빼면 최대값으로 돌아간다고 이해해도 좋다.

* 4비트 정수 기준: `0b1000` - `0b0001` = `0b0111` 

    > `0b0000` 앞에 추가적인 캐리 비트(`1`)가 있다고 가정하고 연산이 진행된다.

    * 4비트 정수에서 `0b1000`은 최소값인 -8이다.
    * 여기에 1을 빼면 이론적으로 -9가 되어야 하지만 `0b0111`은 7이다.

## 정리

* 컴퓨터는 모든 데이터를 `0`과 `1`의 이진수로 저장하고 표현한다.
* 진법 간 변환은 2진수 기반의 규칙을 이해하면 쉽게 수행할 수 있다.
* 2의 보수는 가장 일반적으로 사용되는 정수 표현 방식이다.
* 2의 보수는 음수를 비트 반전 후 1을 더해 표현하며 연산이 간단하고 0을 중복 없이 표현할 수 있다.