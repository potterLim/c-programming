# 16. 비트 연산자 (Bitwise Operators)

비트 연산자는 데이터를 구성하는 개별 비트(0 또는 1)에 직접 작용하는 연산자이다. 컴퓨터는 모든 정보를 0과 1의 이진수로 저장하며 이 이진 표현을 직접 다룰 수 있는 도구가 바로 비트 연산이다. 따라서 비트 연산은 데이터의 가장 근본적인 표현과 조작 수단이라 할 수 있다.

비트 연산은 단순한 논리 연산을 넘어서 데이터 압축(packing), 마스킹(masking), 플래그 제어 등 수많은 응용 분야에서 핵심적인 역할을 한다. 이 장에서는 각 비트 연산자의 작동 원리와 실용적 쓰임새를 중점적으로 살펴본다.

## C의 비트 연산자 종류

| 연산자 | 설명                 | 예시                          |
| ------ | -------------------- | ----------------------------- |
| `&`    | AND: 둘 다 1일 때 1  | `0b1101 & 0b0110` → `0b0100`  |
| `\|`   | OR: 하나라도 1이면 1 | `0b1101 \| 0b1110` → `0b1111` |
| `^`    | XOR: 서로 다를 때 1  | `0b1101 ^ 0b0110` → `0b1011`  |
| `~`    | NOT: 비트 반전       | `~0b1101` → `0b11110010`      |
| `<<`   | 왼쪽 시프트          | `0b1101 << 1` → `0b1010`      |
| `>>`   | 오른쪽 시프트        | `0b1101 >> 1` → `0b0110`      |

> * 정수형을 비트 연산할 경우 왼쪽 시프트 연산(`<<`)은 값을 2의 거듭제곱만큼 곱하는 효과가 있으며 오른쪽 시프트(`>>`)은 2의 거듭제곱만큼 나누는 효과가 있다.
> * 부호 있는 정수형의 오른쪽 시프트 연산(`>>`)은 컴파일러마다 결과가 다를 수 있어 주의가 필요하다(implementation-defined).

## 비트 연산 예제 (8비트 기준 시각화)

### AND (`&`)
```c
int a = 5;       // 00000101
int b = 3;       // 00000011
int c = a & b;   // 00000001 => 1
```

### OR (`|`)
```c
int c = a | b;   // 00000111 => 7
```

### XOR (`^`)
```c
int c = a ^ b;   // 00000110 => 6
```

### NOT (`~`)
```c
int a = 5;       // 00000101
int c = ~a;      // 11111010
```

### Shift (`<<`, `>>`)
```c
int a = 4;       // 00000100
int b = a << 1;  // 00001000 
int c = a >> 1;  // 00000010 
```

* 괄호 필수: *연산자 우선순위가 낮기 때문에 `if ((x & 1) == 1)`처럼 괄호로 명확히 표현해야 함
* `unsigned` 정수형으로 비트 연산하는 것이 안전함

## 비트 연산의 실전 응용 예시

### 마스킹 (Masking)

마스킹은 비트 연산을 통해 특정 비트만을 선택하거나 제거하는 기법이다. 일반적으로 하나의 값에 대해 `AND(&)` 연산과 마스크(mask)를 조합하여 원하는 비트만 남기는 방식으로 사용된다. 

마스크는 관심 있는 비트 위치만 1로 설정하고 나머지는 0으로 설정한 이진수이다. 이때 `AND` 연산을 수행하면 마스크에서 1인 위치의 비트만 원래 값에서 보존되고 나머지는 0이 된다.

```c
unsigned char val = 0b11011101;
unsigned char mask = 0b00001111;  // 하위 4비트만 남기고 나머지는 제거
unsigned char lower4 = val & mask;  // 결과: 00001101
```

반대로 `OR(|)` 연산과 `~(NOT)` 연산을 활용하면 특정 비트를 설정하거나 지우는 것도 가능하다.

* 특정 비트를 설정: `value = value | mask;`
* 특정 비트를 지움: `value = value & ~mask;`


### XOR를 이용한 값 스왑하기

XOR 연산은 두 비트가 서로 다를 때 1, 같을 때 0이 되는 성질이 있다. 이를 이용하면 임시 변수 없이 두 값을 맞바꿀 수 있다.

```c
int a = 5, b = 7;
a = a ^ b;
b = a ^ b;
a = a ^ b;

// a == 7, b == 5
```

### 자기 자신과 XOR하여 0 만들기

자기 자신과 XOR 연산을 수행하면 항상 0이 되는 성질을 이용하여 변수 값을 간단히 초기화할 수 있다.

```c
a = a ^ a;

// a == 0
```

### 대소문자 변환하기 (ASCII 기반)

알파벳 대문자와 소문자는 ASCII 코드에서 5번째 비트(0x20)의 차이를 가진다. 이 비트를 조작하면 대소문자를 쉽게 변환할 수 있다.

```c
char c = 'C';
c = c | 0x20;  // 'c'로 변환
c = c & ~0x20; // 'C'로 변환
```

### 짝수 / 홀수 판별하기

2진수에서 마지막 비트가 0이면 짝수, 1이면 홀수이므로 다음과 같이 판별할 수 있다.

```c
if ((num & 1) == 0) {
    // 짝수
} else {
    // 홀수
}
```

### 2의 승수 여부 판별하기

2의 승수는 이진수로 표현했을 때 하나의 비트만 1인 수이다. 이 특징을 이용하여 다음과 같이 판별할 수 있다.

```c
if (num > 0 && (num & (num - 1)) == 0) {
    // num은 2의 승수
}
```

## 정리

* 비트 연산자는 C 언어에서 데이터를 가장 낮은 수준에서 조작할 수 있는 강력한 도구이다.
* 마스킹, 대소문자 변환, 짝수/홀수 판별, 2의 승수 판별, 값 스왑 등 다양한 작업을 간결하게 처리할 수 있다.
* 부호 있는 정수형의 시프트 연산처럼 구현에 따라 동작이 달라질 수 있는 부분도 반드시 주의해야 한다.
