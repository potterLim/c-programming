# 8. 재귀 함수와 응용 (Recursion and Applications)

## 재귀 함수란?

C 언어에서는 함수가 자기 자신을 다시 호출할 수 있다.  
이러한 방식을 재귀 호출(recursion)이라고 하며 특정 문제를 더 작은 단위로 나누어 해결할 수 있을 때 유용하게 사용된다.

```c
int factorial(int n)
{
    if (n == 1)
    {
        return 1;
    }
    return n * factorial(n - 1);
}
```

이처럼 함수가 자기 자신을 계속 호출하면서 종료 조건(base case)에 도달할 때까지 작업을 반복하고
그 결과를 되돌려 받으면서 최종 결과를 계산한다.

## 재귀 함수의 기본 구조

```c
반환형 함수이름(매개변수)
{
    if (종료 조건)
    {
        return 어떤 값;
    }
    else
    {
        return 자기 자신을 호출하면서 문제를 단순화한 값;
    }
}
```

> 반드시 종료 조건이 있어야 한다.  
> 종료 조건이 없으면 함수가 무한히 자신을 호출하여 스택 오버플로우가 발생할 수 있다.

## 왜 재귀가 필요한가?

재귀는 반복문으로도 대체할 수 있지만, 다음과 같은 경우에는 오히려 **재귀가 더 명확하고 자연스러운 표현**이 된다.

### 문제의 구조가 재귀적인 경우

- 수학적 정의 자체가 재귀적인 경우  
  예: 팩토리얼, 피보나치 수열

- 문제 해결을 위해 문제를 더 작은 문제로 나눠야 하는 경우  
  예: 하노이의 탑, 분할 정복 알고리즘

- 트리 구조 탐색  
  예: 이진 트리, 디렉토리 순회

### 반복문으로 풀면 코드가 복잡해지는 경우

- 중첩 반복이나 깊이 있는 탐색이 필요한 문제  
  예: DFS, 백트래킹(N-Queen, 미로 찾기 등)

## 어떤 문제에서 유용한가?

| 상황                        | 재귀 사용 예시            | 설명                                        |
| --------------------------- | ------------------------- | ------------------------------------------- |
| 수학적 정의가 재귀적일 때   | 팩토리얼, 피보나치        | 정의 자체가 자기 참조적 구조                |
| 트리나 그래프를 탐색할 때   | DFS, 이진 트리 순회       | 각 노드가 다시 서브트리를 가지는 구조       |
| 문제를 나누어 정복할 때     | 병합 정렬, 퀵 정렬        | 문제를 분할하고 해결한 뒤 병합              |
| 모든 경우를 시도해야 할 때  | 조합, 순열, 백트래킹 문제 | 가능한 모든 경우를 탐색하며 되돌아가는 구조 |
| 계층 구조를 순회할 때       | 디렉토리 탐색             | 디렉토리 안에 디렉토리가 있는 구조          |

## 재귀 사고방식 (Recursive Thinking)

재귀를 잘 사용하려면 문제를 더 작은 동일한 문제로 줄이는 사고가 필요하다.

예: factorial(5)

```
factorial(5)
→ 5 × factorial(4)
→ 5 × (4 × factorial(3))
→ ...
→ 5 × 4 × 3 × 2 × 1
→ 120
```

이처럼 가장 단순한 상황(base case)에서부터 시작해 결과를 되돌려 받으며 전체 계산을 완성하는 방식이다.

## 재귀 vs 반복

| 항목       | 재귀                       | 반복문                         |
|------------|----------------------------|--------------------------------|
| 표현 방식  | 자기 자신을 호출           | while, for 사용                 |
| 종료 조건  | base case                  | 조건식이 false가 되면 종료      |
| 장점       | 구조가 단순하고 직관적     | 구현이 명시적이고 빠름           |
| 단점       | 스택 사용, 성능 저하 가능  | 표현이 복잡해질 수 있음         |

## 예제 코드

### 팩토리얼

```c
int factorial(int n)
{
    if (n == 1)
    {
        return 1;
    }
    return n * factorial(n - 1);
}
```

### 피보나치 수열

```c
int fibonacci(int n)
{
    if (n == 0)
    {
        return 0;
    }
    else if (n == 1)
    {
        return 1;
    }
    return fibonacci(n - 1) + fibonacci(n - 2);
}
```

> 피보나치는 중복 호출이 많아 비효율적일 수 있다.  
> 반복문으로 작성하는 것이 더 효율적이지만 설명을 위한 예시이다.

### 하노이의 탑

```c
void hanoi(int n, char from, char to, char temp)
{
    if (n == 1)
    {
        printf("Move disk 1 from %c to %c\n", from, to);
        return;
    }

    hanoi(n - 1, from, temp, to);
    printf("Move disk %d from %c to %c\n", n, from, to);
    hanoi(n - 1, temp, to, from);
}
```

## 주의할 점

* 종료 조건을 빠뜨리면 무한 재귀 호출 발생
* 호출 스택이 깊어지면 프로그램 종료 (스택 오버플로우)
* 중복 호출이 많은 경우 반복문 또는 동적 계획법(DP) 사용 고려

## 정리

* 재귀 함수는 자기 자신을 호출하여 문제를 더 작은 단위로 해결한다.
* 반드시 종료 조건(base case)이 있어야 하며, 그렇지 않으면 무한 호출된다.
* 반복보다 재귀가 더 자연스러운 경우가 많다.
* 중복 호출이 많은 경우 성능 저하에 주의해야 한다.